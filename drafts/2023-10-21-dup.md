---
title: Duplication
---

What if we implemented binding structure using mutable references?

```ocaml
type 'a expf =
    | Var of 'a ref
    | Lam of 'a ref * 'a expf
    | App of 'a expf * 'a expf

type exp = Fix of exp option expf
```

This gives a really unique advantage when implementing substitution. The beta-reduction rule
`(lam x. t) s --> [s/x]t` can be implemented without recursively traversing `t` to perform a
subsitution. Instead, we simply use `x := s; t`. The idea is that a _bound_ variable is
uninstantiated, but a _free_ variable gets instantiated with another expression (or a value in a CBV
semantics).

In this approach, something funny happens if we use the same abstraction _twice_.
Consider this lambda term `t = lam f. lam x. f (f x)`. Let's trace `t (lam y. t2) c`.

- `f := (lam y. t2); (lam x. f (f x)) c`
- `f := (lam y. t2); x := c; f (f x)`
- `f := (lam y. t2); x := c; y := c; f t2`
- `f := (lam y. t2); x := c; y := c; y := t2; t2`

This introduces a problem. `t2` on line 3 contains the free variable `y` bound to `c`. This same
`t2` becomes the instantiation of `y` following the second application of `f`. But now `t2` will
contain `y` referring to `t2` and the binding structure has created a recursive loop, when it
shouldn't have.

The problem is that we referred to `f` _twice_. When we do that, we need to make a copy of `f` so
that the references become fresh. This implementation requires a substructural logic, forbidding
repeated use of the same variable more than once.
However, this is limiting, so we add a first-class copying construct
`let dup (x1, x2) = t in t'`.

We can patch up the example above like this: `t = lam f. lam x. let dup (f1, f2) = f in f1 (f2 x)`

Now let's trace `t (lam y. t2) c`.

- `f := (lam y. t2); (lam x. let dup (f1, f2) = f in f1 (f2 x)) c`
- `f := (lam y. t2); x := c; let dup (f1, f2) = f in f1 (f2 x) `
